// Copyright (c) Meta Platforms, Inc. and affiliates.

using UnityEngine;
using UnityEngine.Assertions;

namespace Oculus.Interaction.ComprehensiveSample
{
    /// <summary>
    /// Should be applied to a transform that is controlled by an Animator.
    /// When the ActiveState's condition is true, this saves and restores its transform's pre-Animator pose,
    /// essentially overriding the Animator. Useful for items that are normally controlled by an Animator
    /// but may be held by a player, to prevent the Animator overriding the pose generated by the player.
    /// </summary>
    public class ConditionalAnimatorOverride : ActiveStateObserver
    {
        [SerializeField]
        private CustomAnimatorUpdate _animator;
        [SerializeField]
        float _changeTime = 0.5f;
        [SerializeField]
        float _changeDelay = 0f;
        [SerializeField]
        bool _position = true;
        [SerializeField]
        bool _rotation = true;

        private float _animatorWeight = 1;

        public IActiveState ActiveState { get; private set; }

        private Pose _poseBeforeAnimator;

        protected virtual void OnEnable()
        {
            _animator.WhenWillUpdate += HandleWillUpdate;
            _animator.WhenUpdated += HandleUpdated;
        }

        protected virtual void OnDisable()
        {
            _animator.WhenWillUpdate -= HandleWillUpdate;
            _animator.WhenUpdated -= HandleUpdated;
        }

        private void HandleWillUpdate()
        {
            _poseBeforeAnimator = transform.GetPose(Space.Self);
        }

        private void HandleUpdated()
        {
            Pose animatorPose = transform.GetPose(Space.Self);
            var pose = new Pose()
            {
                position = Vector3.Lerp(_poseBeforeAnimator.position, animatorPose.position, _position ? _animatorWeight : 1),
                rotation = Quaternion.Lerp(_poseBeforeAnimator.rotation, animatorPose.rotation, _rotation ? _animatorWeight : 1),
            };
            transform.SetPose(pose, Space.Self);
        }

        protected override void HandleActiveStateChanged()
        {
            float targetAnimatorWeight = Active ? 0 : 1;
            float duration = Active ? 0 : Mathf.Abs(_animatorWeight - targetAnimatorWeight) * _changeTime;
            float delay = Active ? 0 : _changeDelay;
            TweenRunner.Tween(_animatorWeight, targetAnimatorWeight, duration, x => _animatorWeight = x).Delay(delay).SetID(this);
        }
    }
}
